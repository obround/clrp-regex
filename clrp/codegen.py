TEMPLATE = r'''# +----------------------------------------+
# | THIS CODE HAS BEEN GENERATED BY clrp   |
# | DO NOT EDIT                            |
# +----------------------------------------+

# errors
class ParseError(Exception): pass

# accept action
class Accept: pass

# shift action
class Shift:
    def __init__(self, transition_state):
        self.transition_state = transition_state

# reduce action
class Reduce:
    def __init__(self, lhs, rhs):
        self.lhs = lhs
        self.rhs = rhs

# main parser
class Parser:
    def __init__(self):
        self.dispatch = {{{dispatch}}}
        self.table = {{
            {table}
        }}

    def format_tree(self, tree, level=0, inc=1):
        ret = ""
        if isinstance(tree, dict):
            for lhs, children in tree.items():
                ret += " " * level + lhs + "\n"
                ret += self.format_tree(children, level + inc)
        elif isinstance(tree, list):
            for item in tree:
                child = self.format_tree(
                    item, level + (inc if not isinstance(item, list) else 0))
                ret += child
        else:
            ret += " " * level + tree + "\n"
        return ret

    def parse(self, tokens, build_tree=False):
        if not build_tree and not self.dispatch:
            raise ValueError("dispatch required to build ast")
        # add the '$' to mark EOF
        tokens.append("$")
        index = 0
        stack = [0]
        node_stack = []

        cur_token = tokens[index]
        while True:
            try:
                move = self.table[stack[-1], cur_token]
            except KeyError as e:
                raise ParseError(f"no transition in table for {{e}}")
            if isinstance(move, Shift):
                # shift a token on the stack
                stack.append(cur_token)
                node_stack.append(cur_token)
                stack.append(move.transition_state)

                index += 1
                cur_token = tokens[index]

            elif isinstance(move, Reduce):
                if move.rhs != [""]:
                    # pop 2 * the amount of prods, and replace
                    # it with the prod's non-terminal
                    stack = stack[:-(2 * len(move.rhs))]
                    children = [
                        node_stack.pop() for _ in range(0, len(move.rhs))
                    ]
                    # get the node's children
                    if build_tree:
                        node_stack.append({{
                            move.lhs:
                            list(reversed(children))
                        }})
                    else:
                        node_stack.append(self.dispatch[move.lhs](
                            list(reversed(children))))
                else:
                    node_stack.append([])
                top = stack[-1]
                stack.append(move.lhs)
                try:
                    stack.append(self.table[top, move.lhs])
                except KeyError as e:
                    raise ParseError(f"no transition in table for {{e}}")

            elif isinstance(move, Accept):
                # if not all the tokens were seen before
                # we got the start symbol: error
                assert index == len(tokens) - 1, "garbage after parsed stream"
                # remove the $ an return the parse node_stack
                tokens.remove("$")
                return node_stack

'''
